#:kivy 1.10.1

<NewFormBox>:
    publisher_dc_toggle: _dc_toggle
    publisher_marvel_toggle: _marvel_toggle
    publisher_dark_horse_toggle: _dark_horse_toggle
    publisher_image_toggle: _image_toggle

    other_publisher_toggle: _other_publisher_toggle
    other_publisher_text: _other_publisher_text

    size_hint_y: None
    height: self.minimum_height
    FieldBox:
        height: dp(50)
        FieldLabel:
            text: "Publisher(s)"
            height: dp(50)
            valign: 'center'
            on_touch_down: print(root.form_data)
        FieldBox:
            id: _publisher_images
            _root: root
            spacing: 0
            height: dp(50)
            halign: 'center'
            PublisherToggle:
                id: _dc_toggle
                publisher: 'dc'
                size: dp(50), dp(50)
                on_release: _title_text.focus = True if root.publisher_count else False
                on_release: _other_publisher_text.focus = True if not root.publisher_count and _other_publisher_toggle.state == 'down' and _other_publisher_text else False
            Label:
                width: (_publisher_images.width - (_dc_toggle.width + _marvel_toggle.width + _dark_horse_toggle.width + _image_toggle.width + _other_publisher_toggle.width)) / 4
            PublisherToggle:
                id: _marvel_toggle
                publisher: 'marvel'
                size: dp(110), dp(50)
                on_release: _title_text.focus = True if root.publisher_count else False
                on_release: _other_publisher_text.focus = True if not root.publisher_count and _other_publisher_toggle.state == 'down' and _other_publisher_text else False
            Label:
                width: (_publisher_images.width - (_dc_toggle.width + _marvel_toggle.width + _dark_horse_toggle.width + _image_toggle.width + _other_publisher_toggle.width)) / 4
            PublisherToggle:
                id: _dark_horse_toggle
                publisher: 'dark_horse'
                size: dp(34), dp(50)
                on_release: _title_text.focus = True if root.publisher_count else False
                on_release: _other_publisher_text.focus = True if not root.publisher_count and _other_publisher_toggle.state == 'down' and _other_publisher_text else False
            Label:
                width: (_publisher_images.width - (_dc_toggle.width + _marvel_toggle.width + _dark_horse_toggle.width + _image_toggle.width + _other_publisher_toggle.width)) / 4
            PublisherToggle:
                id: _image_toggle
                publisher: 'image'
                size: dp(24), dp(50)
                on_release: _title_text.focus = True if root.publisher_count else False
                on_release: _other_publisher_text.focus = True if not root.publisher_count and _other_publisher_toggle.state == 'down' and _other_publisher_text else False
            Label:
                width: (_publisher_images.width - (_dc_toggle.width + _marvel_toggle.width + _dark_horse_toggle.width + _image_toggle.width + _other_publisher_toggle.width)) / 4
            TextToggleButton:
                id: _other_publisher_toggle
                text: 'Other'
                on_release: _other_publisher_text.focus = True if self.state == 'down' else False
                on_release: _title_text.focus = True if self.state == 'normal' and root.publisher_count else False

    FieldBox:
        FieldLabel:
        FieldBox:
            PredictiveTextInput:
                id: _other_publisher_text
                string_ending: ', '
                hint_text: ' separate publishers with commas'
                opacity: 1 if _other_publisher_toggle.state == 'down' else 0
                disabled: False if _other_publisher_toggle.state == 'down' else True
                on_text: self.suggest_text(app.db_cursor(), 'PUBLISHERS', 'publisher') if self.text else None
                on_text: root.publisher_text = self.text if self.text else ''
                on_text_validate: self.get_focus_next().focus = True if not self.current_suggested_word and self.text else False
                # status_bar
                default_text: "Enter name(s) of publisher(s), separated by commas. Enter an imprint in the following format: Imprint (Publisher), eg. Vertigo (DC)."
                on_focus: root.status_bar.set_status(self.default_text) if self.focus else root.status_bar.clear_status()
                on_text: root.status_bar.set_status(self.default_text) if self.focus else None
                on_text: root.status_bar.set_status("Press enter to auto complete suggested text. Current suggested text is \"" + self.current_suggested_word + "\"") if self.current_suggested_word and self.text else None

    FieldBox:
        FieldLabel:
            text: "Title"
        TextInput:
            id: _title_text
#                        text_validate_unfocus: False
            on_text_validate: self.get_focus_next().focus = True if self.text else False
            on_focus: root.form_data['title'] = self.text
            # status_bar
            on_focus: root.status_bar.set_status("Enter the comic's title.") if self.focus else root.status_bar.clear_status()

    FieldBox:
        FieldLabel:
            text: "Format"
        FieldBox:
            PredictiveTextInput:
                id: _format_text
                on_text: self.suggest_text(app.db_cursor(), 'FORMATS', 'format') if self.text else None
                on_text_validate: self.get_focus_next().focus = True if not self.current_suggested_word else False
                on_focus: root.form_data['format'] = self.text if self.text else None
                # status_bar
                on_focus: root.status_bar.set_status("Enter the format of the standard issues.") if self.focus else root.status_bar.clear_status()

            FieldLabel:
                text: "Volume #"
            TextInput:
                id: _vol_text
                size_hint_x: None
                width: dp(65)
                on_focus: root.form_data['volume'] = self.text
                on_text_validate: self.get_focus_next().focus = True
                # status_bar
                on_focus: root.status_bar.set_status("Enter the volume number, if any.") if self.focus else root.status_bar.clear_status()

    FieldBox:
        FieldLabel:
            text: "Run dates"
        FieldBox:
            DateInput:
                id: _start_date_text
                status_bar: root.status_bar
#                            text_validate_unfocus: False
                on_focus: self.set_date(root.form_data, 'start_date') if (not self.focus and not self.get_focus_previous().focus) and self.text else None
                on_text_validate: self.set_date(root.form_data, 'start_date')
                # status_bar
                default_text: "Enter the date in one of these formats: \"DD/MM/YYYY\", \"MM/YYYY\" or just \"YYYY\"."
                on_focus: root.status_bar.set_status(self.default_text) if self.focus else root.status_bar.clear_status()
            FieldLabel:
                text: "to"
                halign: 'center'
            DateInput:
                id: _end_date_text
                status_bar: root.status_bar
#                            text_validate_unfocus: False
                disabled: True if root.ongoing_series or not _start_date_text.text else False
                on_focus: self.set_date(root.form_data, 'end_date') if (not self.focus and not self.get_focus_previous().focus) and self.text else None
                on_text_validate: self.set_date(root.form_data, 'end_date')
                # status_bar
                #default_text: "Enter the date in one of these formats: \"DD/MM/YYYY\", \"MM/YYYY\" or just \"YYYY\"."
                on_focus: root.status_bar.set_status(_start_date_text.default_text) if self.focus else root.status_bar.clear_status()

    FieldBox:
        FieldLabel:
            text: 'Grouping'
        FieldBox:
            PredictiveTextInput:
                id: _group_text
#                            text_validate_unfocus: False
                on_text: self.suggest_text(app.db_cursor(), 'GROUPS', 'name') if self.text else None
                on_text: self.current_suggested_word = '' if not self.text else self.current_suggested_word
                string_ending: ''
                on_text_validate: self.complete_string() if self.current_suggested_word else None
                on_text_validate: root.set_grouping_info(app.db_cursor(), self) if not self.current_suggested_word and self.text else None
                on_text_validate: self.get_focus_next().focus = True if not self.text else False
#                        on_focus: root.data['grouping'] = self.text
                # status_bar
                on_focus: root.status_bar.set_status("Enter grouping info if needed. Multiple groups may be entered separated by commas, eg: 'Batman, Robin'. Order matters.") if self.focus else root.status_bar.clear_status()
            Button:
                text: 'add'
                disabled: True if not _group_text.text else False
                on_release: root.set_grouping_info(app.db_cursor(), _group_text)
            Button:
                text: 'clear last'
                disabled: True if len(root.group_chain) == 0 else False
                on_release: del root.group_chain[-1]; _group_text.text = ''
#            Button:
#                text: 'test'
#                on_release: root.set_group(app, app.db_cursor())
    FieldBox:
        height: self.minimum_height
        FieldLabel:
        BlueLabel:
            size_hint_x: 1
            text: root.grouping_text if root.grouping_text else ' '

    FieldBox:
        height: dp(100)
        FieldLabel:
            height: dp(100)
            valign: 'top'
            text: 'Notes'
        TextInput:
            id: _notes_text
            height: dp(100)
            multiline: True
            on_text: root.form_data['notes'] = self.text.strip() if self.text else None
            on_text_validate: _issue_number_text.focus = True if not self.text else False
            # status_bar
            default_text: "Enter any kind of note you wish. That's some real freedom, man!"
            on_focus: root.status_bar.set_status(self.default_text) if self.focus else root.status_bar.clear_status()
